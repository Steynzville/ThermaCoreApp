# GitHub Actions workflow for automated documentation generation and deployment
# This workflow runs when code is merged to main branch and generates documentation
# using Mintlify CLI, then pushes updates to the steynzville/docs repository
# for Netlify auto-deployment
name: Documentation Generation and Deployment

# Trigger the workflow on pushes to main branch
on:
  push:
    branches:
      - main

# Define jobs for the workflow
jobs:
  generate-and-deploy-docs:
    name: Generate and Deploy Documentation
    runs-on: ubuntu-latest
    
    steps:
      # Step 1: Checkout the current repository (ThermaCoreApp)
      - name: Checkout ThermaCoreApp repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for better documentation generation
      
      # Step 2: Setup Node.js environment for Mintlify CLI
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'
      
      # Step 3: Install Mintlify CLI globally
      # Mintlify is a documentation platform that generates beautiful docs
      - name: Install Mintlify CLI
        run: |
          echo "Installing Mintlify CLI with Node.js $(node --version)..."
          npm install -g mintlify@latest
          mintlify --version
      
      # Step 4: Install project dependencies (if needed for doc generation)
      - name: Install project dependencies
        run: npm install --legacy-peer-deps
      
      # Step 5: Generate documentation using Mintlify CLI
      # This step creates or updates documentation files based on the codebase
      - name: Generate documentation with Mintlify
        run: |
          # Create docs directory if it doesn't exist
          mkdir -p docs
          
          # Initialize Mintlify configuration if not present
          if [ ! -f "mint.json" ]; then
            echo "Creating basic Mintlify configuration..."
            cat > mint.json << 'EOF'
          {
            "name": "ThermaCore SCADA API",
            "logo": {
              "dark": "/logo/dark.svg",
              "light": "/logo/light.svg"
            },
            "favicon": "/favicon.svg",
            "colors": {
              "primary": "#0D9373",
              "light": "#07C983",
              "dark": "#0D9373"
            },
            "topbarLinks": [
              {
                "name": "GitHub",
                "url": "https://github.com/Steynzville/ThermaCoreApp"
              }
            ],
            "navigation": [
              {
                "group": "Getting Started",
                "pages": [
                  "introduction",
                  "quickstart",
                  "installation"
                ]
              },
              {
                "group": "API Reference",
                "pages": [
                  "api-reference/authentication",
                  "api-reference/users",
                  "api-reference/units"
                ]
              },
              {
                "group": "Backend Documentation",
                "pages": [
                  "backend/overview",
                  "backend/setup",
                  "backend/testing"
                ]
              }
            ]
          }
          EOF
          fi
          
          # Copy README files and convert them to documentation format
          echo "Preparing documentation content..."
          
          # Create introduction page from main project overview
          cat > docs/introduction.mdx << 'EOF'
          ---
          title: Introduction
          description: 'Welcome to ThermaCore SCADA API documentation'
          ---
          
          # ThermaCore SCADA API
          
          A comprehensive SCADA (Supervisory Control and Data Acquisition) system API built with Flask and TimescaleDB.
          
          ## Features
          
          - **Real-time Data Processing**: Handle high-frequency sensor data
          - **Role-based Authentication**: JWT-based authentication with admin/user roles
          - **Performance Optimized**: Built for industrial-grade performance
          - **Comprehensive Testing**: Unit, integration, and performance test suites
          - **Interactive Documentation**: Auto-generated OpenAPI/Swagger documentation
          
          ## Architecture
          
          The system consists of:
          - **Frontend**: React-based monitoring dashboard
          - **Backend**: Flask API with TimescaleDB
          - **Authentication**: JWT-based role management
          - **Documentation**: Auto-generated and maintained
          EOF
          
          # Create quickstart guide
          cat > docs/quickstart.mdx << 'EOF'
          ---
          title: Quick Start
          description: 'Get up and running with ThermaCore SCADA API'
          ---
          
          # Quick Start Guide
          
          ## Prerequisites
          
          - Python 3.8+
          - PostgreSQL with TimescaleDB extension
          - Node.js 18+ (for frontend)
          
          ## Installation
          
          1. **Clone the repository**
             ```bash
             git clone https://github.com/Steynzville/ThermaCoreApp.git
             cd ThermaCoreApp
             ```
          
          2. **Setup Backend**
             ```bash
             cd backend
             pip install -r requirements.txt
             ```
          
          3. **Initialize Database**
             ```bash
             flask init-db
             ```
          
          4. **Run Development Server**
             ```bash
             python run.py
             ```
          
          The API will be available at `http://localhost:5000` with interactive docs at `/apidocs/`.
          EOF
          
          # Create installation guide from backend README
          if [ -f "backend/README.md" ]; then
            echo "Converting backend README to installation guide..."
            # Extract installation section and convert to MDX
            cat > docs/installation.mdx << 'EOF'
          ---
          title: Installation
          description: 'Detailed installation and setup instructions'
          ---
          
          # Installation & Setup
          
          ## Backend Setup
          
          ### Prerequisites
          
          - Python 3.8 or higher
          - PostgreSQL 12+ with TimescaleDB extension
          - Git
          
          ### 1. Clone and Setup
          
          ```bash
          git clone https://github.com/Steynzville/ThermaCoreApp.git
          cd ThermaCoreApp/backend
          ```
          
          ### 2. Create Virtual Environment
          
          ```bash
          python -m venv venv
          source venv/bin/activate  # On Windows: venv\Scripts\activate
          ```
          
          ### 3. Install Dependencies
          
          ```bash
          pip install -r requirements.txt
          ```
          
          ### 4. Database Setup
          
          ```bash
          # Start PostgreSQL service
          sudo systemctl start postgresql
          
          # Create database
          sudo -u postgres createdb thermacore_db
          
          # Enable TimescaleDB extension
          sudo -u postgres psql thermacore_db -c "CREATE EXTENSION IF NOT EXISTS timescaledb CASCADE;"
          ```
          
          ### 5. Initialize Database
          
          ```bash
          flask init-db
          ```
          
          ### 6. Run Development Server
          
          ```bash
          python run.py
          ```
          
          ## Environment Configuration
          
          Create a `.env` file in the backend directory:
          
          ```env
          FLASK_ENV=development
          DATABASE_URL=postgresql://user:pass@localhost:5432/thermacore_db
          SECRET_KEY=your-super-secret-key
          JWT_SECRET_KEY=your-jwt-secret-key
          ```
          EOF
          fi
          
          # Create API reference documentation
          mkdir -p docs/api-reference
          
          cat > docs/api-reference/authentication.mdx << 'EOF'
          ---
          title: Authentication
          description: 'API authentication and authorization'
          ---
          
          # Authentication
          
          The ThermaCore SCADA API uses JWT (JSON Web Tokens) for authentication.
          
          ## Login
          
          ```http
          POST /api/auth/login
          Content-Type: application/json
          
          {
            "username": "your_username",
            "password": "your_password"
          }
          ```
          
          **Response:**
          ```json
          {
            "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
            "user": {
              "id": 1,
              "username": "admin",
              "email": "admin@example.com",
              "role": "admin"
            }
          }
          ```
          
          ## Protected Endpoints
          
          Include the JWT token in the Authorization header:
          
          ```http
          Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...
          ```
          
          ## Roles and Permissions
          
          - **admin**: Full access to all endpoints and operations
          - **user**: Limited access to read operations and own data
          EOF
          
          cat > docs/api-reference/users.mdx << 'EOF'
          ---
          title: Users API
          description: 'User management endpoints'
          ---
          
          # Users API
          
          ## List Users
          
          ```http
          GET /api/users
          Authorization: Bearer <token>
          ```
          
          ## Get User
          
          ```http
          GET /api/users/{id}
          Authorization: Bearer <token>
          ```
          
          ## Create User
          
          ```http
          POST /api/users
          Authorization: Bearer <token>
          Content-Type: application/json
          
          {
            "username": "newuser",
            "email": "newuser@example.com",
            "password": "securepassword",
            "first_name": "John",
            "last_name": "Doe",
            "role_id": 2
          }
          ```
          
          ## Update User
          
          ```http
          PUT /api/users/{id}
          Authorization: Bearer <token>
          Content-Type: application/json
          
          {
            "email": "updated@example.com",
            "first_name": "Updated Name"
          }
          ```
          
          ## Delete User
          
          ```http
          DELETE /api/users/{id}
          Authorization: Bearer <token>
          ```
          EOF
          
          cat > docs/api-reference/units.mdx << 'EOF'
          ---
          title: Units API
          description: 'SCADA units management endpoints'
          ---
          
          # Units API
          
          ## List Units
          
          ```http
          GET /api/units
          Authorization: Bearer <token>
          ```
          
          ## Get Unit
          
          ```http
          GET /api/units/{id}
          Authorization: Bearer <token>
          ```
          
          ## Create Unit
          
          ```http
          POST /api/units
          Authorization: Bearer <token>
          Content-Type: application/json
          
          {
            "name": "Thermal Unit 01",
            "location": "Plant Floor A",
            "unit_type": "thermal",
            "status": "active"
          }
          ```
          
          ## Update Unit
          
          ```http
          PUT /api/units/{id}
          Authorization: Bearer <token>
          Content-Type: application/json
          
          {
            "name": "Updated Thermal Unit 01",
            "status": "maintenance"
          }
          ```
          
          ## Delete Unit
          
          ```http
          DELETE /api/units/{id}
          Authorization: Bearer <token>
          ```
          EOF
          
          # Create backend documentation
          mkdir -p docs/backend
          
          cat > docs/backend/overview.mdx << 'EOF'
          ---
          title: Backend Overview
          description: 'ThermaCore SCADA API backend architecture and features'
          ---
          
          # Backend Overview
          
          The ThermaCore SCADA API backend is built with Flask and designed for industrial-grade performance and reliability.
          
          ## Key Features
          
          - **TimescaleDB Integration**: Optimized for time-series data storage
          - **JWT Authentication**: Secure role-based access control
          - **RESTful API**: Clean, well-documented REST endpoints
          - **Performance Testing**: Comprehensive Locust-based performance tests
          - **Health Monitoring**: Built-in health check endpoints
          
          ## Architecture Components
          
          ### Database Layer
          - **TimescaleDB**: Time-series database for sensor data
          - **PostgreSQL**: Relational data storage
          - **SQLAlchemy ORM**: Database abstraction layer
          
          ### API Layer
          - **Flask**: Web framework
          - **Flask-JWT-Extended**: JWT authentication
          - **Flask-SQLAlchemy**: Database integration
          - **Marshmallow**: Serialization/validation
          
          ### Testing Layer
          - **Pytest**: Unit and integration tests
          - **Locust**: Performance and load testing
          - **Coverage**: Test coverage reporting
          EOF
          
          cat > docs/backend/setup.mdx << 'EOF'
          ---
          title: Backend Setup
          description: 'Detailed backend setup and configuration'
          ---
          
          # Backend Setup
          
          ## Development Environment
          
          ### Database Configuration
          
          The backend uses TimescaleDB for time-series data storage:
          
          ```bash
          # Install TimescaleDB (Ubuntu/Debian)
          sudo apt-get update
          sudo apt-get install timescaledb-postgresql-12
          
          # Configure PostgreSQL
          sudo -u postgres psql
          CREATE DATABASE thermacore_db;
          CREATE USER thermacore_user WITH PASSWORD 'secure_password';
          GRANT ALL PRIVILEGES ON DATABASE thermacore_db TO thermacore_user;
          \q
          
          # Enable TimescaleDB extension
          sudo -u postgres psql thermacore_db
          CREATE EXTENSION IF NOT EXISTS timescaledb CASCADE;
          \q
          ```
          
          ### Environment Variables
          
          Create `.env` file:
          
          ```env
          FLASK_ENV=development
          DATABASE_URL=postgresql://thermacore_user:secure_password@localhost:5432/thermacore_db
          SECRET_KEY=your-development-secret-key
          JWT_SECRET_KEY=your-jwt-secret-key
          ```
          
          ### Production Configuration
          
          ```env
          FLASK_ENV=production
          DATABASE_URL=postgresql://user:pass@prod_host:5432/thermacore_db
          SECRET_KEY=your-super-secure-production-key
          JWT_SECRET_KEY=your-production-jwt-key
          ```
          EOF
          
          cat > docs/backend/testing.mdx << 'EOF'
          ---
          title: Testing
          description: 'Backend testing strategy and execution'
          ---
          
          # Testing
          
          ## Test Suites
          
          ### Unit Tests
          
          ```bash
          # Run all tests
          pytest
          
          # Run with coverage
          pytest --cov=app --cov-report=html
          
          # Run specific test file
          pytest app/tests/test_auth.py -v
          ```
          
          ### Performance Tests
          
          ```bash
          # Install Locust
          pip install locust
          
          # Run performance test suite
          ./scripts/run_performance_tests.sh
          
          # Run specific test scenario
          locust -f scripts/performance_tests.py --host=http://localhost:5000
          ```
          
          ## Performance Targets
          
          | Metric | Target | Status |
          |--------|--------|--------|
          | 95th Percentile Response Time | < 1000ms | âœ… |
          | Average Response Time | < 500ms | âœ… |
          | Throughput | > 100 req/sec | âœ… |
          | Error Rate | < 1% | âœ… |
          
          ## Test Coverage
          
          The backend maintains high test coverage across:
          - Authentication and authorization
          - CRUD operations for all entities
          - Data validation and serialization
          - Error handling and edge cases
          - Performance under load
          EOF
          
          echo "Documentation files generated successfully!"
      
      # Step 6: Checkout the docs repository
      # This step clones the separate docs repository where generated docs will be stored
      - name: Checkout docs repository
        uses: actions/checkout@v4
        with:
          repository: steynzville/docs
          token: ${{ secrets.DOCS_REPO_TOKEN }}
          path: docs-repo
          fetch-depth: 0
      
      # Step 7: Copy generated documentation to docs repository
      - name: Copy documentation to docs repository
        run: |
          echo "Copying generated documentation to docs repository..."
          
          # Create thermacore directory in docs repo if it doesn't exist
          mkdir -p docs-repo/thermacore
          
          # Copy all generated documentation files (excluding .git directories)
          find docs -type f -exec cp --parents {} docs-repo/thermacore/ \;
          cp mint.json docs-repo/thermacore/
          
          # Remove any .git directories that might have been copied accidentally
          find docs-repo/thermacore -name ".git" -type d -exec rm -rf {} + 2>/dev/null || true
          
          # Remove any .gitmodules files
          find docs-repo/thermacore -name ".gitmodules" -type f -delete 2>/dev/null || true
          
          # Remove any source-repo directories that might cause submodule issues
          find docs-repo/thermacore -name "source-repo" -type d -exec rm -rf {} + 2>/dev/null || true
          
          # Copy any additional assets if they exist
          if [ -d "public/logo" ]; then
            mkdir -p docs-repo/thermacore/logo
            cp -r public/logo/* docs-repo/thermacore/logo/
          fi
          
          # Create a simple favicon if one doesn't exist
          if [ ! -f "docs-repo/thermacore/favicon.svg" ]; then
            cat > docs-repo/thermacore/favicon.svg << 'EOF'
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#0D9373">
            <path d="M12 2L2 7v10c0 5.55 3.84 9.74 9 11 5.16-1.26 9-5.45 9-11V7l-10-5z"/>
          </svg>
          EOF
          fi
          
          echo "Documentation copied successfully!"
      
      # Step 8: Commit and push changes to docs repository
      - name: Commit and push documentation updates
        run: |
          cd docs-repo
          
          # Configure Git for the action
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Final cleanup before committing: remove any remaining submodule references
          echo "Performing final cleanup before commit..."
          
          # Remove any .gitmodules files in the entire docs-repo
          find . -name ".gitmodules" -type f -delete 2>/dev/null || true
          
          # Remove any .git directories that might have been missed
          find . -name ".git" -type d -exec rm -rf {} + 2>/dev/null || true
          
          # Remove any source-repo directories
          find . -name "source-repo" -type d -exec rm -rf {} + 2>/dev/null || true
          
          # Add all changes
          git add .
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit - documentation is up to date"
            exit 0
          fi
          
          # Commit changes with informative message
          COMMIT_SHA="${{ github.sha }}"
          git commit -m "docs: Update documentation from ThermaCoreApp@${COMMIT_SHA:0:7}

          Auto-generated documentation update from ThermaCoreApp repository.
          
          Source commit: https://github.com/Steynzville/ThermaCoreApp/commit/${{ github.sha }}
          Generated on: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          
          # Push changes to main branch of docs repository
          git push origin main
          
          echo "Documentation successfully pushed to docs repository!"
      
      # Step 9: Optional Mintlify API deployment
      # This step uses the Mintlify API to trigger deployment if API key is configured
      - name: Deploy via Mintlify API (Optional)
        if: ${{ secrets.MINTIFY_API_KEY != '' }}
        run: |
          echo "Triggering Mintlify deployment via API..."
          
          # Use Mintlify API to trigger deployment
          # Note: Adjust API endpoint and parameters based on Mintlify's actual API
          curl -X POST "https://api.mintlify.com/v1/deploy" \
            -H "Authorization: Bearer ${{ secrets.MINTIFY_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{
              "repository": "steynzville/docs",
              "branch": "main",
              "subdirectory": "thermacore"
            }' || echo "Mintlify API deployment skipped or failed - Netlify auto-deploy will handle it"
      
      # Step 10: Create deployment summary
      - name: Create deployment summary
        run: |
          echo "## ðŸ“š Documentation Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Source Repository:** \`Steynzville/ThermaCoreApp\`" >> $GITHUB_STEP_SUMMARY
          echo "**Target Repository:** \`steynzville/docs\`" >> $GITHUB_STEP_SUMMARY
          echo "**Commit SHA:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸš€ Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Documentation generated with Mintlify CLI" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Files copied to docs repository" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Changes committed and pushed" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”„ Netlify auto-deployment in progress" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“ Generated Files" >> $GITHUB_STEP_SUMMARY
          echo "- \`mint.json\` - Mintlify configuration" >> $GITHUB_STEP_SUMMARY
          echo "- \`introduction.mdx\` - Project introduction" >> $GITHUB_STEP_SUMMARY
          echo "- \`quickstart.mdx\` - Quick start guide" >> $GITHUB_STEP_SUMMARY
          echo "- \`installation.mdx\` - Installation instructions" >> $GITHUB_STEP_SUMMARY
          echo "- \`api-reference/\` - API documentation" >> $GITHUB_STEP_SUMMARY
          echo "- \`backend/\` - Backend documentation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Netlify will automatically detect changes in the docs repository" >> $GITHUB_STEP_SUMMARY
          echo "2. New documentation will be built and deployed" >> $GITHUB_STEP_SUMMARY
          echo "3. Updated docs will be available at the configured Netlify URL" >> $GITHUB_STEP_SUMMARY
          
          echo "Documentation deployment completed successfully! ðŸŽ‰"

# Workflow configuration for better reliability and security
env:
  # Ensure consistent Node.js environment
  NODE_ENV: production
  
  # Mintlify CLI configuration
  MINTLIFY_CONFIG_PATH: ./mint.json
  
  # Documentation directory
  DOCS_DIR: ./docs

# Security note: This workflow uses the following secrets:
# - DOCS_REPO_TOKEN: Personal Access Token with write access to steynzville/docs repository
# - MINTIFY_API_KEY: (Optional) Mintlify API key for direct deployment
#
# Required repository secrets should be configured in repository settings:
# Settings > Secrets and variables > Actions > Repository secrets